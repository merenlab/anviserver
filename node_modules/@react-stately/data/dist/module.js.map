{"mappings":"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","sources":["packages/@react-stately/data/src/index.ts","packages/@react-stately/data/src/useAsyncList.ts","packages/@react-stately/data/src/useListData.ts","packages/@react-stately/data/src/useTreeData.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useAsyncList} from './useAsyncList';\nexport {useTreeData} from './useTreeData';\nexport {useListData} from './useListData';\n\nexport type {ListOptions, ListData} from './useListData';\nexport type {AsyncListOptions, AsyncListData} from './useAsyncList';\nexport type {TreeOptions, TreeData} from './useTreeData';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createListActions, ListData, ListState} from './useListData';\nimport {Key, Reducer, useEffect, useReducer} from 'react';\nimport {LoadingState, Selection, SortDescriptor} from '@react-types/shared';\n\nexport interface AsyncListOptions<T, C> {\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** The initial sort descriptor. */\n  initialSortDescriptor?: SortDescriptor,\n  /** The initial filter text. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that loads the data for the items in the list. */\n  load: AsyncListLoadFunction<T, C>,\n  /**\n   * An optional function that performs sorting. If not provided,\n   * then `sortDescriptor` is passed to the `load` function.\n   */\n  sort?: AsyncListLoadFunction<T, C>\n}\n\ntype AsyncListLoadFunction<T, C> = (state: AsyncListLoadOptions<T, C>) => AsyncListStateUpdate<T, C> | Promise<AsyncListStateUpdate<T, C>>;\n\ninterface AsyncListLoadOptions<T, C> {\n  /** The items currently in the list. */\n  items: T[],\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n  /** The current sort descriptor for the list. */\n  sortDescriptor: SortDescriptor,\n  /** An abort signal used to notify the load function that the request has been aborted. */\n  signal: AbortSignal,\n  /** The pagination cursor returned from the last page load. */\n  cursor?: C,\n  /** The current filter text used to perform server side filtering. */\n  filterText?: string,\n  /** The current loading state of the list. */\n  loadingState?: LoadingState\n}\n\ninterface AsyncListStateUpdate<T, C> {\n  /** The new items to append to the list. */\n  items: Iterable<T>,\n  /** The keys to add to the selection. */\n  selectedKeys?: Iterable<Key>,\n  /** The sort descriptor to set. */\n  sortDescriptor?: SortDescriptor,\n  /** The pagination cursor to be used for the next page load. */\n  cursor?: C,\n  /** The updated filter text for the list. */\n  filterText?: string\n}\n\ninterface AsyncListState<T, C> extends ListState<T> {\n  state: LoadingState,\n  items: T[],\n  // disabledKeys?: Iterable<Key>,\n  selectedKeys: Selection,\n  // selectedKey?: Key,\n  // expandedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  cursor?: C\n}\n\ntype ActionType = 'success' | 'error' | 'loading' | 'loadingMore' | 'sorting' | 'update' | 'filtering';\ninterface Action<T, C> {\n  type: ActionType,\n  items?: Iterable<T>,\n  selectedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  updater?: (state: ListState<T>) => ListState<T>,\n  cursor?: C,\n  filterText?: string\n}\n\nexport interface AsyncListData<T> extends ListData<T> {\n  /** Whether data is currently being loaded. */\n  isLoading: boolean,\n  /** If loading data failed, then this contains the error that occurred. */\n  error?: Error,\n  // disabledKeys?: Set<Key>,\n  // selectedKey?: Key,\n  // expandedKeys?: Set<Key>,\n  /** The current sort descriptor for the list. */\n  sortDescriptor?: SortDescriptor,\n\n  /** Reloads the data in the list. */\n  reload(): void,\n  /** Loads the next page of data in the list. */\n  loadMore(): void,\n  /** Triggers sorting for the list. */\n  sort(descriptor: SortDescriptor): void,\n  /** The current loading state for the list. */\n  loadingState: LoadingState\n}\n\nfunction reducer<T, C>(data: AsyncListState<T, C>, action: Action<T, C>): AsyncListState<T, C> {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          selectedKeys = action.selectedKeys ?? data.selectedKeys;\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          selectedKeys = (data.selectedKeys === 'all' || action.selectedKeys === 'all')\n            ? 'all'\n            : new Set([...data.selectedKeys, ...(action.selectedKeys ?? [])]);\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\n\n/**\n * Manages state for an immutable async loaded list data structure, and provides convenience methods to\n * update the data over time. Manages loading and error states, pagination, and sorting.\n */\nexport function useAsyncList<T, C = string>(options: AsyncListOptions<T, C>): AsyncListData<T> {\n  const {\n    load,\n    sort,\n    initialSelectedKeys,\n    initialSortDescriptor,\n    getKey = (item: any) => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n\n  let [data, dispatch] = useReducer<Reducer<AsyncListState<T, C>, Action<T, C>>>(reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n\n  const dispatchFetch = async (action: Action<T, C>, fn: AsyncListLoadFunction<T, C>) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({...action, abortController});\n      let previousFilterText = action.filterText ?? data.filterText;\n\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null,\n        filterText: previousFilterText\n      });\n\n      let filterText = response.filterText ?? previousFilterText;\n      dispatch({type: 'success', ...response, abortController});\n\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && (filterText !== previousFilterText) && !abortController.signal.aborted) {\n        dispatchFetch({type: 'filtering', filterText}, load);\n      }\n    } catch (e) {\n      dispatch({type: 'error', error: e, abortController});\n    }\n  };\n\n  useEffect(() => {\n    dispatchFetch({type: 'loading'}, load);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key: Key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({type: 'loading'}, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) {\n        return;\n      }\n\n      dispatchFetch({type: 'loadingMore'}, load);\n    },\n    sort(sortDescriptor: SortDescriptor) {\n      dispatchFetch({type: 'sorting', sortDescriptor}, sort || load);\n    },\n    ...createListActions({...options, getKey, cursor: data.cursor}, fn => {\n      dispatch({type: 'update', updater: fn});\n    }),\n    setFilterText(filterText: string) {\n      dispatchFetch({type: 'filtering', filterText}, load);\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useState} from 'react';\nimport {Selection} from '@react-types/shared';\n\nexport interface ListOptions<T> {\n  /** Initial items in the list. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: 'all' | Iterable<Key>,\n  /** The initial text to filter the list by. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns whether a item matches the current filter text. */\n  filter?: (item: T, filterText: string) => boolean\n}\n\nexport interface ListData<T> {\n  /** The items in the list. */\n  items: T[],\n\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Selection): void,\n\n  /** The current filter text. */\n  filterText: string,\n\n  /** Sets the filter text. */\n  setFilterText(filterText: string): void,\n\n  /**\n   * Gets an item from the list by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): T,\n\n  /**\n   * Inserts items into the list at the given index.\n   * @param index - The index to insert into.\n   * @param values - The values to insert.\n   */\n  insert(index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends items to the list.\n   * @param values - The values to insert.\n   */\n  append(...values: T[]): void,\n\n  /**\n   * Prepends items to the list.\n   * @param value - The value to insert.\n   */\n  prepend(...values: T[]): void,\n\n  /**\n   * Removes items from the list by their keys.\n   * @param keys - The keys of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the list that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the list.\n   * @param key - The key of the item to move.\n   * @param toIndex - The index to move the item to.\n   */\n  move(key: Key, toIndex: number): void,\n\n  /**\n   * Moves one or more items before a given key.\n   * @param key - The key of the item to move the items before.\n   * @param keys - The keys of the items to move.\n   */\n  moveBefore(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Moves one or more items after a given key.\n   * @param key - The key of the item to move the items after.\n   * @param keys - The keys of the items to move.\n   */\n  moveAfter(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Updates an item in the list.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\nexport interface ListState<T> {\n  items: T[],\n  selectedKeys: Selection,\n  filterText: string\n}\n\ninterface CreateListOptions<T, C> extends ListOptions<T> {\n  cursor?: C\n}\n\n/**\n * Manages state for an immutable list data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useListData<T>(options: ListOptions<T>): ListData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    filter,\n    initialFilterText = ''\n  } = options;\n\n  // Store both items and filteredItems in state so we can go back to the unfiltered list\n  let [state, setState] = useState<ListState<T>>({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  });\n\n  let filteredItems = useMemo(\n    () => filter ? state.items.filter(item => filter(item, state.filterText)) : state.items,\n    [state.items, state.filterText, filter]);\n\n  return {\n    ...state,\n    items: filteredItems,\n    ...createListActions({getKey}, setState),\n    getItem(key: Key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n  };\n}\n\nexport function createListActions<T, C>(opts: CreateListOptions<T, C>, dispatch: (updater: (state: ListState<T>) => ListState<T>) => void): Omit<ListData<T>, 'items' | 'selectedKeys' | 'getItem' | 'filterText'> {\n  let {cursor, getKey} = opts;\n  return {\n    setSelectedKeys(selectedKeys: Selection) {\n      dispatch(state => ({\n        ...state,\n        selectedKeys\n      }));\n    },\n    setFilterText(filterText: string) {\n      dispatch(state => ({\n        ...state,\n        filterText\n      }));\n    },\n    insert(index: number, ...values: T[]) {\n      dispatch(state => insert(state, index, ...values));\n    },\n    insertBefore(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index, ...values);\n      });\n    },\n    insertAfter(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index + 1, ...values);\n      });\n    },\n    prepend(...values: T[]) {\n      dispatch(state => insert(state, 0, ...values));\n    },\n    append(...values: T[]) {\n      dispatch(state => insert(state, state.items.length, ...values));\n    },\n    remove(...keys: Key[]) {\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n\n        let selection: Selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (let key of keys) {\n            selection.delete(key);\n          }\n        }\n        if (cursor == null && items.length === 0) {\n          selection = new Set();\n        }\n\n        return {\n          ...state,\n          items,\n          selectedKeys: selection\n        };\n      });\n    },\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') {\n          return {\n            ...state,\n            items: [],\n            selectedKeys: new Set()\n          };\n        }\n\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return {\n          ...state,\n          items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n    move(key: Key, toIndex: number) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        let copy = state.items.slice();\n        let [item] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item);\n        return {\n          ...state,\n          items: copy\n        };\n      });\n    },\n    moveBefore(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return move(state, indices, toIndex);\n      });\n    },\n    moveAfter(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return move(state, indices, toIndex + 1);\n      });\n    },\n    update(key: Key, newValue: T) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        return {\n          ...state,\n          items: [\n            ...state.items.slice(0, index),\n            newValue,\n            ...state.items.slice(index + 1)\n          ]\n        };\n      });\n    }\n  };\n}\n\nfunction insert<T>(state: ListState<T>, index: number, ...values: T[]): ListState<T> {\n  return {\n    ...state,\n    items: [\n      ...state.items.slice(0, index),\n      ...values,\n      ...state.items.slice(index)\n    ]\n  };\n}\n\nfunction move<T>(state: ListState<T>, indices: number[], toIndex: number): ListState<T> {\n  // Shift the target down by the number of items being moved from before the target\n  for (let index of indices) {\n    if (index < toIndex) {\n      toIndex--;\n    }\n  }\n\n  let moves = indices.map(from => ({\n    from,\n    to: toIndex++\n  }));\n\n  // Shift later from indices down if they have a larger index\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i].from;\n    for (let j = i; j < moves.length; j++) {\n      let b = moves[j].from;\n\n      if (b > a) {\n        moves[j].from--;\n      }\n    }\n  }\n\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i];\n    for (let j = moves.length - 1; j > i; j--) {\n      let b = moves[j];\n\n      if (b.from < a.to) {\n        a.to++;\n      } else {\n        b.from++;\n      }\n    }\n  }\n\n  let copy = state.items.slice();\n  for (let move of moves) {\n    let [item] = copy.splice(move.from, 1);\n    copy.splice(move.to, 0, item);\n  }\n\n  return {\n    ...state,\n    items: copy\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useState} from 'react';\n\nexport interface TreeOptions<T extends object> {\n  /** Initial root items in the tree. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns the children for an item object. */\n  getChildren?: (item: T) => T[]\n}\n\ninterface TreeNode<T extends object> {\n  /** A unique key for the tree node. */\n  key: Key,\n  /** The key of the parent node. */\n  parentKey: Key,\n  /** The value object for the tree node. */\n  value: T,\n  /** Children of the tree node. */\n  children: TreeNode<T>[]\n}\n\nexport interface TreeData<T extends object> {\n  /** The root nodes in the tree. */\n  items: TreeNode<T>[],\n\n  /** The keys of the currently selected items in the tree. */\n  selectedKeys: Set<Key>,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Set<Key>): void,\n\n  /**\n   * Gets a node from the tree by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): TreeNode<T>,\n\n  /**\n   * Inserts an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param index - The index within the parent to insert into.\n   * @param value - The value to insert.\n   */\n  insert(parentKey: Key | null, index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  append(parentKey: Key | null, ...values: T[]): void,\n\n  /**\n   * Prepends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  prepend(parentKey: Key | null, ...value: T[]): void,\n\n  /**\n   * Removes an item from the tree by its key.\n   * @param key - The key of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the tree that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the tree.\n   * @param key - The key of the item to move.\n   * @param toParentKey - The key of the new parent to insert into.\n   * @param index - The index within the new parent to insert at.\n   */\n  move(key: Key, toParentKey: Key, index: number): void,\n\n  /**\n   * Updates an item in the tree.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\n/**\n * Manages state for an immutable tree data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useTreeData<T extends object>(options: TreeOptions<T>): TreeData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    getChildren = (item: any) => item.children\n  } = options;\n  let map = useMemo(() => new Map<Key, TreeNode<T>>(), []);\n\n  // We only want to compute this on initial render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  let initialNodes = useMemo(() => buildTree(initialItems), []);\n  let [items, setItems] = useState(initialNodes);\n  let [selectedKeys, setSelectedKeys] = useState(new Set<Key>(initialSelectedKeys || []));\n\n  function buildTree(initialItems: T[] = [], parentKey?: Key | null) {\n    return initialItems.map(item => {\n      let node: TreeNode<T> = {\n        key: getKey(item),\n        parentKey: parentKey,\n        value: item,\n        children: null\n      };\n\n      node.children = buildTree(getChildren(item), node.key);\n      map.set(node.key, node);\n      return node;\n    });\n  }\n\n  function updateTree(items: TreeNode<T>[], key: Key, update: (node: TreeNode<T>) => TreeNode<T>) {\n    let node = map.get(key);\n    if (!node) {\n      return items;\n    }\n\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) {\n      deleteNode(node);\n    } else {\n      addNode(newNode);\n    }\n\n    // Walk up the tree and update each parent to refer to the new chilren.\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy: TreeNode<T> = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n\n      let children = nextParent.children;\n      if (newNode == null) {\n        children = children.filter(c => c !== node);\n      }\n\n      copy.children = children.map(child => {\n        if (child === node) {\n          return newNode;\n        }\n\n        return child;\n      });\n\n      map.set(copy.key, copy);\n\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) {\n      items = items.filter(c => c !== node);\n    }\n\n    return items.map(item => {\n      if (item === node) {\n        return newNode;\n      }\n\n      return item;\n    });\n  }\n\n  function addNode(node: TreeNode<T>) {\n    map.set(node.key, node);\n    for (let child of node.children) {\n      addNode(child);\n    }\n  }\n\n  function deleteNode(node: TreeNode<T>) {\n    map.delete(node.key);\n    for (let child of node.children) {\n      deleteNode(child);\n    }\n  }\n\n  return {\n    items,\n    selectedKeys,\n    setSelectedKeys,\n    getItem(key: Key) {\n      return map.get(key);\n    },\n    insert(parentKey: Key | null, index: number, ...values: T[]) {\n      setItems(items => {\n        let nodes = buildTree(values, parentKey);\n\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) {\n          return [\n            ...items.slice(0, index),\n            ...nodes,\n            ...items.slice(index)\n          ];\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            ...nodes,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    insertBefore(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index, ...values);\n    },\n    insertAfter(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index + 1, ...values);\n    },\n    prepend(parentKey: Key | null, ...values: T[]) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey: Key | null, ...values: T[]) {\n      if (parentKey == null) {\n        this.insert(null, items.length, ...values);\n      } else {\n        let parentNode = map.get(parentKey);\n        if (!parentNode) {\n          return;\n        }\n\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove(...keys: Key[]) {\n      let newItems = items;\n      for (let key of keys) {\n        newItems = updateTree(newItems, key, () => null);\n      }\n\n      setItems(newItems);\n\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) {\n        if (!map.has(key)) {\n          selection.delete(key);\n        }\n      }\n\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key: Key, toParentKey: Key, index: number) {\n      setItems(items => {\n        let node = map.get(key);\n        if (!node) {\n          return items;\n        }\n\n        items = updateTree(items, key, () => null);\n\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n\n        return updateTree(items, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            movedNode,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    update(oldKey: Key, newValue: T) {\n      setItems(items => updateTree(items, oldKey, oldNode => {\n        let node: TreeNode<T> = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n\n        node.children = buildTree(getChildren(newValue), node.key);\n        return node;\n      }));\n    }\n  };\n}\n"],"names":[],"version":3,"file":"module.js.map"}