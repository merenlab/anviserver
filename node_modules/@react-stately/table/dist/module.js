import {Section as $6555104ff085bef4$re_export$Section, useCollection as $1BfjW$useCollection} from "@react-stately/collections";
import $1BfjW$react, {useRef as $1BfjW$useRef, useState as $1BfjW$useState, useCallback as $1BfjW$useCallback, useMemo as $1BfjW$useMemo} from "react";
import {useGridState as $1BfjW$useGridState, GridCollection as $1BfjW$GridCollection} from "@react-stately/grid";

function $30561577df230a30$export$f61abf052f87399f(widths) {
    return Array.from(widths).map((e)=>e[1]
    ).reduce((acc, cur)=>acc + cur
    , 0);
}
function $30561577df230a30$export$1994a077b98ee0d5(width) {
    return width != null && (!isNaN(width) || String(width).match(/^(\d+)(?=%$)/) !== null);
}
function $30561577df230a30$var$parseFractionalUnit(width) {
    if (!width) return 1;
    let match = width.match(/^(\d+)(?=fr$)/);
    // if width is the incorrect format, just deafult it to a 1fr
    if (!match) {
        console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, 'defaulting to \'1fr\'');
        return 1;
    }
    return parseInt(match[0], 10);
}
function $30561577df230a30$export$7bbad27896f7ae9f(width, tableWidth) {
    if (typeof width === 'string') {
        let match = width.match(/^(\d+)(?=%$)/);
        if (!match) throw new Error('Only percentages or numbers are supported for static column widths');
        return tableWidth * (parseInt(match[0], 10) / 100);
    }
    return width;
}
function $30561577df230a30$export$59185c62a7544aa0(maxWidth, tableWidth) {
    return maxWidth != null ? $30561577df230a30$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;
}
function $30561577df230a30$export$f556054ce4358701(minWidth, tableWidth) {
    return minWidth != null ? $30561577df230a30$export$7bbad27896f7ae9f(minWidth, tableWidth) : 75;
}
function $30561577df230a30$var$mapDynamicColumns(dynamicColumns, availableSpace, tableWidth) {
    let fractions = dynamicColumns.reduce((sum, column)=>sum + $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth)
    , 0);
    let columns = dynamicColumns.map((column, index)=>{
        const targetWidth = $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth) * availableSpace / fractions;
        const delta = Math.max($30561577df230a30$export$f556054ce4358701(column.props.minWidth, tableWidth) - targetWidth, targetWidth - $30561577df230a30$export$59185c62a7544aa0(column.props.maxWidth, tableWidth));
        return {
            ...column,
            index: index,
            delta: delta
        };
    });
    return columns;
}
function $30561577df230a30$var$findDynamicColumnWidths(dynamicColumns, availableSpace, tableWidth) {
    let fractions = dynamicColumns.reduce((sum, col)=>sum + $30561577df230a30$var$parseFractionalUnit(col.props.defaultWidth)
    , 0);
    const columns = dynamicColumns.map((column)=>{
        const targetWidth = $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth) * availableSpace / fractions;
        let width = Math.max($30561577df230a30$export$f556054ce4358701(column.props.minWidth, tableWidth), Math.min(Math.floor(targetWidth), $30561577df230a30$export$59185c62a7544aa0(column.props.maxWidth, tableWidth)));
        column.calculatedWidth = width;
        availableSpace -= width;
        fractions -= $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth);
        return column;
    });
    return columns;
}
function $30561577df230a30$export$a870e6692ac5ccb2(dynamicColumns, availableSpace, tableWidth) {
    let columns = $30561577df230a30$var$mapDynamicColumns(dynamicColumns, availableSpace, tableWidth);
    columns.sort((a, b)=>b.delta - a.delta
    );
    columns = $30561577df230a30$var$findDynamicColumnWidths(columns, availableSpace, tableWidth);
    columns.sort((a, b)=>a.index - b.index
    );
    return columns;
}



function $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {
    const { getDefaultWidth: getDefaultWidth , tableWidth: defaultTableWidth = null  } = props;
    const { columns: columns1  } = state;
    const columnsRef = $1BfjW$useRef([]);
    const tableWidth = $1BfjW$useRef(defaultTableWidth);
    const isResizing = $1BfjW$useRef(null);
    const startResizeContentWidth = $1BfjW$useRef();
    const [columnWidths, setColumnWidths] = $1BfjW$useState(new Map(columns1.map((col)=>[
            col.key,
            0
        ]
    )));
    const columnWidthsRef = $1BfjW$useRef(columnWidths);
    const affectedColumnWidthsRef = $1BfjW$useRef([]);
    const [resizedColumns, setResizedColumns] = $1BfjW$useState(new Set());
    const resizedColumnsRef = $1BfjW$useRef(resizedColumns);
    const [currentlyResizingColumn, setCurrentlyResizingColumn] = $1BfjW$useState(null);
    function setColumnWidthsForRef(newWidths) {
        columnWidthsRef.current = newWidths;
        // new map so that change detection is triggered
        setColumnWidths(newWidths);
    }
    /*
    returns the resolved column width in this order:
    previously calculated width -> controlled width prop -> uncontrolled defaultWidth prop -> dev assigned width -> default dynamic width
  */ let getResolvedColumnWidth = $1BfjW$useCallback((column)=>{
        let columnProps = column.props;
        var _width, ref, ref1;
        return (resizedColumns === null || resizedColumns === void 0 ? void 0 : resizedColumns.has(column.key)) ? columnWidthsRef.current.get(column.key) : (ref1 = (ref = (_width = columnProps.width) !== null && _width !== void 0 ? _width : columnProps.defaultWidth) !== null && ref !== void 0 ? ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(column.props)) !== null && ref1 !== void 0 ? ref1 : '1fr';
    }, [
        getDefaultWidth,
        resizedColumns
    ]);
    let getStaticAndDynamicColumns = $1BfjW$useCallback((columns)=>columns.reduce((acc, column)=>{
            let width = getResolvedColumnWidth(column);
            return $30561577df230a30$export$1994a077b98ee0d5(width) ? {
                ...acc,
                staticColumns: [
                    ...acc.staticColumns,
                    column
                ]
            } : {
                ...acc,
                dynamicColumns: [
                    ...acc.dynamicColumns,
                    column
                ]
            };
        }, {
            staticColumns: [],
            dynamicColumns: []
        })
    , [
        getResolvedColumnWidth
    ]);
    let buildColumnWidths = $1BfjW$useCallback((affectedColumns, availableSpace)=>{
        const widths = new Map();
        let remainingSpace = availableSpace;
        const { staticColumns: staticColumns , dynamicColumns: dynamicColumns  } = getStaticAndDynamicColumns(affectedColumns);
        staticColumns.forEach((column)=>{
            let width = getResolvedColumnWidth(column);
            let w = $30561577df230a30$export$7bbad27896f7ae9f(width, tableWidth.current);
            widths.set(column.key, w);
            remainingSpace -= w;
        });
        // dynamic columns
        if (dynamicColumns.length > 0) {
            const newColumnWidths = $30561577df230a30$export$a870e6692ac5ccb2(dynamicColumns, remainingSpace, tableWidth.current);
            for (let column of newColumnWidths)widths.set(column.key, column.calculatedWidth);
        }
        return widths;
    }, [
        getStaticAndDynamicColumns,
        getResolvedColumnWidth
    ]);
    const prevColKeys = columnsRef.current.map((col)=>col.key
    );
    const colKeys = columns1.map((col)=>col.key
    );
    // if the columns change, need to rebuild widths.
    if (prevColKeys.length !== colKeys.length || !colKeys.every((col, i)=>col === prevColKeys[i]
    )) {
        columnsRef.current = columns1;
        const widths = buildColumnWidths(columns1, tableWidth.current);
        setColumnWidthsForRef(widths);
    }
    function setTableWidth(width) {
        if (width && width !== tableWidth.current) {
            tableWidth.current = width;
            if (!isResizing.current) {
                const widths = buildColumnWidths(columns1, width);
                setColumnWidthsForRef(widths);
            }
        }
    }
    function onColumnResizeStart(column) {
        setCurrentlyResizingColumn(column.key);
        isResizing.current = true;
        startResizeContentWidth.current = $30561577df230a30$export$f61abf052f87399f(columnWidthsRef.current);
    }
    function onColumnResize(column, width) {
        let widthsObj = resizeColumn(column, width);
        affectedColumnWidthsRef.current = widthsObj;
        props.onColumnResize && props.onColumnResize(affectedColumnWidthsRef.current);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    function onColumnResizeEnd(column) {
        props.onColumnResizeEnd && isResizing.current && props.onColumnResizeEnd(affectedColumnWidthsRef.current);
        setCurrentlyResizingColumn(null);
        isResizing.current = false;
        affectedColumnWidthsRef.current = [];
        let widths = new Map(columnWidthsRef.current);
        setColumnWidthsForRef(widths);
    }
    function resizeColumn(column1, newWidth) {
        let boundedWidth = Math.max($30561577df230a30$export$f556054ce4358701(column1.props.minWidth, tableWidth.current), Math.min(Math.floor(newWidth), $30561577df230a30$export$59185c62a7544aa0(column1.props.maxWidth, tableWidth.current)));
        // copy the columnWidths map and set the new width for the column being resized
        let widths = new Map(columnWidthsRef.current);
        widths.set(column1.key, boundedWidth);
        // keep track of all columns that have been sized
        resizedColumnsRef.current.add(column1.key);
        setResizedColumns(resizedColumnsRef.current);
        // get the columns affected by resize and remaining space
        const resizeIndex = columnsRef.current.findIndex((col)=>col.key === column1.key
        );
        let affectedColumns = columnsRef.current.slice(resizeIndex + 1);
        // we only care about the columns that CAN be resized, we ignore static columns.
        let { dynamicColumns: dynamicColumns  } = getStaticAndDynamicColumns(affectedColumns);
        // available space for affected columns
        let availableSpace = columnsRef.current.reduce((acc, column, index)=>{
            if (index <= resizeIndex || $30561577df230a30$export$1994a077b98ee0d5(getResolvedColumnWidth(column))) return acc - widths.get(column.key);
            return acc;
        }, tableWidth.current);
        // merge the unaffected column widths and the recalculated column widths
        let recalculatedColumnWidths = buildColumnWidths(dynamicColumns, availableSpace);
        widths = new Map([
            ...widths,
            ...recalculatedColumnWidths
        ]);
        setColumnWidthsForRef(widths);
        /*
     when getting recalculated columns above, the column being resized is not considered "recalculated"
     so we need to add it to the list of affected columns
    */ let allAffectedColumns = [
            [
                column1.key,
                boundedWidth
            ],
            ...recalculatedColumnWidths
        ].map(([key, width])=>({
                key: key,
                width: width
            })
        );
        return allAffectedColumns;
    }
    var ref2;
    // This function is regenerated whenever columnWidthsRef.current changes in order to get the new correct ref value.
    let getColumnWidth = $1BfjW$useCallback((key)=>(ref2 = columnWidthsRef.current.get(key)) !== null && ref2 !== void 0 ? ref2 : 0
    , [
        columnWidthsRef.current
    ]);
    let getColumnMinWidth = $1BfjW$useCallback((key)=>{
        const columnIndex = columns1.findIndex((col)=>col.key === key
        );
        if (columnIndex === -1) return;
        return $30561577df230a30$export$f556054ce4358701(columns1[columnIndex].props.minWidth, tableWidth.current);
    }, [
        columns1
    ]);
    let getColumnMaxWidth = $1BfjW$useCallback((key)=>{
        const columnIndex = columns1.findIndex((col)=>col.key === key
        );
        if (columnIndex === -1) return;
        return $30561577df230a30$export$59185c62a7544aa0(columns1[columnIndex].props.maxWidth, tableWidth.current);
    }, [
        columns1
    ]);
    return {
        columnWidths: columnWidthsRef,
        setTableWidth: setTableWidth,
        onColumnResize: onColumnResize,
        onColumnResizeStart: onColumnResizeStart,
        onColumnResizeEnd: onColumnResizeEnd,
        getColumnWidth: getColumnWidth,
        getColumnMinWidth: getColumnMinWidth,
        getColumnMaxWidth: getColumnMaxWidth,
        currentlyResizingColumn: currentlyResizingColumn
    };
}





const $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);
function $788781baa30117fa$var$buildHeaderRows(keyMap, columnNodes) {
    let columns = [];
    let seen = new Map();
    for (let column of columnNodes){
        let parentKey = column.parentKey;
        let col = [
            column
        ];
        while(parentKey){
            let parent = keyMap.get(parentKey);
            // If we've already seen this parent, than it is shared
            // with a previous column. If the current column is taller
            // than the previous column, than we need to shift the parent
            // in the previous column so it's level with the current column.
            if (seen.has(parent)) {
                parent.colspan++;
                let { column: column , index: index  } = seen.get(parent);
                if (index > col.length) break;
                for(let i = index; i < col.length; i++)column.splice(i, 0, null);
                // Adjust shifted indices
                for(let i1 = col.length; i1 < column.length; i1++)if (column[i1] && seen.has(column[i1])) seen.get(column[i1]).index = i1;
            } else {
                parent.colspan = 1;
                col.push(parent);
                seen.set(parent, {
                    column: col,
                    index: col.length - 1
                });
            }
            parentKey = parent.parentKey;
        }
        columns.push(col);
        column.index = columns.length - 1;
    }
    let maxLength = Math.max(...columns.map((c)=>c.length
    ));
    let headerRows = Array(maxLength).fill(0).map(()=>[]
    );
    // Convert columns into rows.
    let colIndex = 0;
    for (let column1 of columns){
        let i = maxLength - 1;
        for (let item of column1){
            if (item) {
                // Fill the space up until the current column with a placeholder
                let row = headerRows[i];
                let rowLength = row.reduce((p, c)=>p + c.colspan
                , 0);
                if (rowLength < colIndex) {
                    let placeholder = {
                        type: 'placeholder',
                        key: 'placeholder-' + item.key,
                        colspan: colIndex - rowLength,
                        index: rowLength,
                        value: null,
                        rendered: null,
                        level: i,
                        hasChildNodes: false,
                        childNodes: [],
                        textValue: null
                    };
                    if (row.length > 0) {
                        row[row.length - 1].nextKey = placeholder.key;
                        placeholder.prevKey = row[row.length - 1].key;
                    }
                    row.push(placeholder);
                }
                if (row.length > 0) {
                    row[row.length - 1].nextKey = item.key;
                    item.prevKey = row[row.length - 1].key;
                }
                item.level = i;
                item.colIndex = colIndex;
                row.push(item);
            }
            i--;
        }
        colIndex++;
    }
    // Add placeholders at the end of each row that is shorter than the maximum
    let i = 0;
    for (let row1 of headerRows){
        let rowLength = row1.reduce((p, c)=>p + c.colspan
        , 0);
        if (rowLength < columnNodes.length) {
            let placeholder = {
                type: 'placeholder',
                key: 'placeholder-' + row1[row1.length - 1].key,
                colspan: columnNodes.length - rowLength,
                index: rowLength,
                value: null,
                rendered: null,
                level: i,
                hasChildNodes: false,
                childNodes: [],
                textValue: null,
                prevKey: row1[row1.length - 1].key
            };
            row1.push(placeholder);
        }
        i++;
    }
    return headerRows.map((childNodes, index)=>{
        let row = {
            type: 'headerrow',
            key: 'headerrow-' + index,
            index: index,
            value: null,
            rendered: null,
            level: 0,
            hasChildNodes: true,
            childNodes: childNodes,
            textValue: null
        };
        return row;
    });
}
var tmp = Symbol.iterator;
class $788781baa30117fa$export$596e1b2e2cf93690 extends $1BfjW$GridCollection {
    *[tmp]() {
        yield* this.body.childNodes;
    }
    get size() {
        return [
            ...this.body.childNodes
        ].length;
    }
    getKeys() {
        return this.keyMap.keys();
    }
    getKeyBefore(key) {
        let node = this.keyMap.get(key);
        return node ? node.prevKey : null;
    }
    getKeyAfter(key) {
        let node = this.keyMap.get(key);
        return node ? node.nextKey : null;
    }
    getFirstKey() {
        var ref;
        return (ref = [
            ...this.body.childNodes
        ][0]) === null || ref === void 0 ? void 0 : ref.key;
    }
    getLastKey() {
        var ref;
        let rows = [
            ...this.body.childNodes
        ];
        return (ref = rows[rows.length - 1]) === null || ref === void 0 ? void 0 : ref.key;
    }
    getItem(key) {
        return this.keyMap.get(key);
    }
    at(idx) {
        const keys = [
            ...this.getKeys()
        ];
        return this.getItem(keys[idx]);
    }
    constructor(nodes, prev, opts){
        let rowHeaderColumnKeys = new Set();
        let body;
        let columns = [];
        // Add cell for selection checkboxes if needed.
        if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {
            let rowHeaderColumn = {
                type: 'column',
                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,
                value: null,
                textValue: '',
                level: 0,
                index: 0,
                hasChildNodes: false,
                rendered: null,
                childNodes: [],
                props: {
                    isSelectionCell: true
                }
            };
            columns.unshift(rowHeaderColumn);
        }
        let rows = [];
        let columnKeyMap = new Map();
        let visit = (node)=>{
            switch(node.type){
                case 'body':
                    body = node;
                    break;
                case 'column':
                    columnKeyMap.set(node.key, node);
                    if (!node.hasChildNodes) {
                        columns.push(node);
                        if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);
                    }
                    break;
                case 'item':
                    rows.push(node);
                    return; // do not go into childNodes
            }
            for (let child of node.childNodes)visit(child);
        };
        for (let node1 of nodes)visit(node1);
        let headerRows = $788781baa30117fa$var$buildHeaderRows(columnKeyMap, columns);
        headerRows.forEach((row, i)=>rows.splice(i, 0, row)
        );
        super({
            columnCount: columns.length,
            items: rows,
            visitNode: (node)=>{
                node.column = columns[node.index];
                return node;
            }
        });
        this.columns = columns;
        this.rowHeaderColumnKeys = rowHeaderColumnKeys;
        this.body = body;
        this.headerRows = headerRows;
        // Default row header column to the first one.
        if (this.rowHeaderColumnKeys.size === 0) this.rowHeaderColumnKeys.add(this.columns[(opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) ? 1 : 0].key);
    }
}



const $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {
    ascending: 'descending',
    descending: 'ascending'
};
function $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {
    let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = $1BfjW$useState(false);
    let { selectionMode: selectionMode = 'none'  } = props;
    let context = $1BfjW$useMemo(()=>({
            showSelectionCheckboxes: props.showSelectionCheckboxes && selectionMode !== 'none',
            selectionMode: selectionMode,
            columns: []
        })
    , [
        props.children,
        props.showSelectionCheckboxes,
        selectionMode
    ]);
    let collection = $1BfjW$useCollection(props, (nodes, prev)=>new $788781baa30117fa$export$596e1b2e2cf93690(nodes, prev, context)
    , context);
    let { disabledKeys: disabledKeys , selectionManager: selectionManager  } = $1BfjW$useGridState({
        ...props,
        collection: collection
    });
    return {
        collection: collection,
        disabledKeys: disabledKeys,
        selectionManager: selectionManager,
        showSelectionCheckboxes: props.showSelectionCheckboxes || false,
        sortDescriptor: props.sortDescriptor,
        isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,
        setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,
        sort (columnKey, direction) {
            var ref;
            props.onSortChange({
                column: columnKey,
                direction: direction !== null && direction !== void 0 ? direction : ((ref = props.sortDescriptor) === null || ref === void 0 ? void 0 : ref.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : 'ascending'
            });
        }
    };
}



function $312ae3b56a94a86e$var$TableHeader(props) {
    return null;
}
$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props) {
    let { children: children , columns: columns  } = props;
    if (typeof children === 'function') {
        if (!columns) throw new Error('props.children was a function but props.columns is missing');
        for (let column of columns)yield {
            type: 'column',
            value: column,
            renderer: children
        };
    } else {
        let columns = [];
        $1BfjW$react.Children.forEach(children, (column)=>{
            columns.push({
                type: 'column',
                element: column
            });
        });
        yield* columns;
    }
};
/**
 * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined
 * as children, or generated dynamically using a function based on the data passed to the `columns` prop.
 */ // We don't want getCollectionNode to show up in the type definition
let $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;



function $4ae5314bf50db1a3$var$TableBody(props) {
    return null;
}
$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {
    let { children: children , items: items1  } = props;
    yield {
        type: 'body',
        hasChildNodes: true,
        props: props,
        *childNodes () {
            if (typeof children === 'function') {
                if (!items1) throw new Error('props.children was a function but props.items is missing');
                for (let item of items1)yield {
                    type: 'item',
                    value: item,
                    renderer: children
                };
            } else {
                let items = [];
                $1BfjW$react.Children.forEach(children, (item)=>{
                    items.push({
                        type: 'item',
                        element: item
                    });
                });
                yield* items;
            }
        }
    };
};
/**
 * A TableBody is a container for the Row elements of a Table. Rows can be statically defined
 * as children, or generated dynamically using a function based on the data passed to the `items` prop.
 */ // We don't want getCollectionNode to show up in the type definition
let $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;



function $1cd244557c2f97d5$var$Column(props) {
    return null;
}
$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context1) {
    let { title: title , children: children , childColumns: childColumns1  } = props;
    let rendered = title || children;
    let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'];
    let fullNodes = yield {
        type: 'column',
        hasChildNodes: !!childColumns1 || title && $1BfjW$react.Children.count(children) > 0,
        rendered: rendered,
        textValue: textValue,
        props: props,
        *childNodes () {
            if (childColumns1) for (let child1 of childColumns1)yield {
                type: 'column',
                value: child1
            };
            else if (title) {
                let childColumns = [];
                $1BfjW$react.Children.forEach(children, (child)=>{
                    childColumns.push({
                        type: 'column',
                        element: child
                    });
                });
                yield* childColumns;
            }
        },
        shouldInvalidate (newContext) {
            // This is a bit of a hack, but it works.
            // If this method is called, then there's a cached version of this node available.
            // But, we need to keep the list of columns in the new context up to date.
            updateContext(newContext);
            return false;
        }
    };
    let updateContext = (context)=>{
        // register leaf columns on the context so that <Row> can access them
        for (let node of fullNodes)if (!node.hasChildNodes) context.columns.push(node);
    };
    updateContext(context1);
};
/**
 * A Column represents a field of each item within a Table. Columns may also contain nested
 * Column elements to represent column groups. Nested columns can be statically defined as
 * children, or dynamically generated using a function based on the `childColumns` prop.
 */ // We don't want getCollectionNode to show up in the type definition
let $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;



function $70d70eb16ea48428$var$Row(props) {
    return null;
}
$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {
    let { children: children , textValue: textValue  } = props;
    yield {
        type: 'item',
        props: props,
        textValue: textValue,
        'aria-label': props['aria-label'],
        hasChildNodes: true,
        *childNodes () {
            // Process cells first
            if (context.showSelectionCheckboxes && context.selectionMode !== 'none') yield {
                type: 'cell',
                key: 'header',
                props: {
                    isSelectionCell: true
                }
            };
            if (typeof children === 'function') for (let column of context.columns)yield {
                type: 'cell',
                element: children(column.key),
                key: column.key // this is combined with the row key by CollectionBuilder
            };
            else {
                let cells = [];
                $1BfjW$react.Children.forEach(children, (cell)=>{
                    cells.push({
                        type: 'cell',
                        element: cell
                    });
                });
                if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);
                yield* cells;
            }
        },
        shouldInvalidate (newContext) {
            // Invalidate all rows if the columns changed.
            return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i)=>c.key !== context.columns[i].key
            ) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.selectionMode !== context.selectionMode;
        }
    };
};
/**
 * A Row represents a single item in a Table and contains Cell elements for each column.
 * Cells can be statically defined as children, or generated dynamically using a function
 * based on the columns defined in the TableHeader.
 */ // We don't want getCollectionNode to show up in the type definition
let $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;


function $941d1d9a6a28982a$var$Cell(props) {
    return null;
}
$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {
    let { children: children  } = props;
    let textValue = props.textValue || (typeof children === 'string' ? children : '') || props['aria-label'] || '';
    yield {
        type: 'cell',
        props: props,
        rendered: children,
        textValue: textValue,
        'aria-label': props['aria-label'],
        hasChildNodes: false
    };
};
/**
 * A Cell represents the value of a single Column within a Table Row.
 */ // We don't want getCollectionNode to show up in the type definition
let $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;





export {$292bc4e09cd0eb62$export$cb895dcf85db1319 as useTableColumnResizeState, $4a0dd036d492cee4$export$907bcc6c48325fd6 as useTableState, $312ae3b56a94a86e$export$f850895b287ef28e as TableHeader, $4ae5314bf50db1a3$export$76ccd210b9029917 as TableBody, $1cd244557c2f97d5$export$816b5d811295e6bc as Column, $70d70eb16ea48428$export$b59bdbef9ce70de2 as Row, $941d1d9a6a28982a$export$f6f0c3fe4ec306ea as Cell, $6555104ff085bef4$re_export$Section as Section};
//# sourceMappingURL=module.js.map
